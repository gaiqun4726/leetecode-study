# 解题模式：

## 算法

1. 双指针（滑动窗口）

- M3：无重复字符最长子串。双指针+位置Map

- M16：最接近的三数之和。选定一个数，左右指针分指首尾，三数之和与目标比较，向中间靠拢。

2. 快慢指针：判断有环的问题。链表有环，快乐数，重复数字

3. 二分查找：局部有序找目标值。循环数组分割点，循环数组找数，山脉数组

4. 回溯：

- M93：复原IP地址。可行解：当前数字是有效数字，部分解个数等于4，数字小于255，无剩余数字。

5. 动态规划：

- M300：最长上升子序列（LIS）。状态：dp[i]以i结尾的LIS长度，状态转移方程：dp[i]=Max(dp[j]+1)，目标值：Max(dp[i])。

6. 广度优先遍历

- M542：01矩阵。目标是到1的距离，把所有1放到初始队列，进行广度遍历。需要visited数组。

- M14262：地图分析。从1开始广度遍历，注意访问上下左右四个方向。需要visited数组。

7. 深度优先遍历

- Q13：机器人的运动范围。从(0,0)开始深度优先遍历，用条件约束可访问的地方，使用visited数组。

- M200：岛屿数量。从非0位置开始dfs遍历，并把遍历过的位置置为0。遍历矩阵中剩余的非0位置，重复上述过程。

8. 多路归并

- M355：设计推特。用户维护定长Feeds，订阅用户多路归并，使用数组首尾两两归并的迭代解法。

9. 排序

- M56：合并区间。区间左边界递增排序，区间逐个比较合并。

- M945：使数组唯一的最小增量。快排，从左到右遍历，后一个数小于等于前一个数的话，把后一个数增加到比前一个数大1。

- M820：单词的压缩编码。单词逆序排序，逐个比较，判断前一个是不是后一个的后缀。
使用StringBuilder.reverse()反转，使用String.endWith()判断是否是后缀。

## 数据结构

1. 链表

- M61：旋转链表。获取长度，首尾相接，断开n-k。

2. 栈

- M151：翻转字符串里的单词。双指针获取单词，用栈反向输出到列表，使用String.join()。

3. 哈希表

- M846：一手顺子。TreeMap保存每张牌的个数，并按牌大小排序，看能否构成整数手的顺子。

4. 矩阵

- P0107：旋转矩阵。旋转九十度，先沿左上右下对角线翻转，再沿竖中轴线翻转。

5. 前缀树Trie

- M820：单词的压缩编码。单词按长度从大到小排序，逐个插入Trie。如果插入过程没有新建结点，则不需计算单词长度。

6. 数据结构设计

- M146：LRU缓存。使用双向链表保存缓存，使用HashMap保存指向链表元素的索引。存取时更新队列和map。

- Q59：队列的最大值。一个队列，一个双向链表。队列作为正常使用，双向链表保存当前最大值。
新元素比链表尾部的大，则链表尾部弹出，然后插入新元素；小于等于链表尾部则插入尾部。

## 数学

1. 表达式求值：逆波兰式求解

2. 排列组合

- M60：第k个排列。以任意字母开头的排列数为(n-1)!，计算k对应第几个数开头，并用余数继续计算剩余的开头字母。

3. 数学问题模拟

- M43：字符串相乘。开辟定长数组，数字倒序打印，注意乘数为0。

## sql

- M177：第N高的薪水。set N = N - 1; select salary from employee limit 1 offset N;

- M180：连续出现的数字。把一张表定义三次，三张表的id连续递增，num相等。以此条件筛选出num并去重。

## 其他

1. 多线程

