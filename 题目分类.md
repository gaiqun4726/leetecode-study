# 解题模式：

## 温习题目数目
截止2020.5.3：44道。

## 算法

1. 双指针（滑动窗口）

- M3：无重复字符最长子串。双指针+位置Map

- M16：最接近的三数之和。选定一个数，左右指针分指首尾，三数之和与目标比较，向中间靠拢。

- M15：三数之和。先将数组排序，然后固定一个值，在这个值右侧用双指针探索。
重复值的处理，在固定值的选择上，只选择第一个重复数字。右侧的双指针，左边的只去第一个重复值，右边只取最后一个重复值。

- M80：删除排序数组的重复元素。一个指针指向应放位置，一个指向遍历的当前位置。当前位置的元素与应放位置之前2个位置的元素不同则放入新元素。

2. 快慢指针：判断有环的问题。

- M142：环形链表。满指针s，快指针f，满足f=2s,f=s+nb，得到f=2nb,s=nb。
在快慢指针重叠后，快指针从链表头重新以步长1运动，f和s再次重叠的点就是环形入口。

快乐数，重复数字

3. 二分查找：局部有序找目标值。

- M153：旋转排序数组中的最小值。二分查找，mid小于mid-1则mid是目标值；否则mid与high比较决定下次二分的部分。

循环数组找数，山脉数组

4. 回溯：

- M93：复原IP地址。可行解：当前数字是有效数字，部分解个数等于4，数字小于255，无剩余数字。

5. 动态规划：

- M300：最长上升子序列（LIS）。状态：dp[i]以i结尾的LIS长度，状态转移方程：dp[i]=Max(dp[j]+1)，目标值：Max(dp[i])。

- E53：最大子序和。dp[i]表示以i结尾的字符串的最大和，dp[i] = Max{dp[i-1]+ai, ai}，求Max(dp[i])。
可以不用dp求解，用双指针求解。如果尾指针的数字加入使得子序和为负，则头指针移动到尾指针的下一个位置，重新计算子序和。

- M1143：最长公共子序列（LCS）。状态：dp[i][j]以i，j结尾的字符串最长公共子序列长度。
转移方程：if ai == bj，dp[i][j] = dp[i-1][j-1] + 1。else dp[i][j] = Max(dp[i-1][j], dp[i][j-1])。
目标值：dp[aLen-1][bLen-1]。
注意初始化：dp[0][0] = a0 == b0 ? 1 : 0。dp[i][0] = ai == b0 ? 1 : dp[i-1][0]。

- M337：打家劫舍。用自顶向下备忘录的解法。备忘录存储树节点对应的最大数值。目标值就是根节点和孙子层的和，与孩子层的和的最大值。

6. 广度优先遍历

- M542：01矩阵。多源广度优先遍历。目标是到1的距离，把所有1放到初始队列，进行广度遍历。需要visited数组。

- M14262：地图分析。多源广度优先遍历。从1开始广度遍历，注意访问上下左右四个方向。需要visited数组。

- M994：腐烂的橘子。多源广度优先遍历。把腐烂的橘子放入初始队列，每分钟感染周边的橘子。队列为空时终止，统计未被感染的橘子以判断是否可全部感染。

7. 深度优先遍历

- Q13：机器人的运动范围。从(0,0)开始深度优先遍历，用条件约束可访问的地方，使用visited数组。

- M200：岛屿数量。从非0位置开始dfs遍历，并把遍历过的位置置为0。遍历矩阵中剩余的非0位置，重复上述过程。

8. 多路归并

- M355：设计推特。用户维护定长Feeds，订阅用户多路归并，使用数组首尾两两归并的迭代解法。

9. 排序

- M56：合并区间。区间左边界递增排序，区间逐个比较合并。

- M945：使数组唯一的最小增量。快排，从左到右遍历，后一个数小于等于前一个数的话，把后一个数增加到比前一个数大1。

- M820：单词的压缩编码。单词逆序排序，逐个比较，判断前一个是不是后一个的后缀。
使用StringBuilder.reverse()反转，使用String.endWith()判断是否是后缀。

- M1288：删除被覆盖的区间。区间按左边界递增、右边界递减排序。
剩余区间数开始为区间总个数，记录当前最右边界，逐个比较右边界，如果可以覆盖则区间个数减1；否则更新区间右边界。

- M912：排序数组。
快排，partition方法把pivot放在最终位置，并返回该位置pos；sort方法用pos把数组分为两个，递归调用sort排序。注意sort递归结束的条件。
归并排序，split把数组分为两段，然后递归调用sort排序两段数组，最后用merge合并两段数组。注意递归结束条件。

10. 回文串

- M5：最长回文子串。使用中心扩展法，遍历字符串。注意回文串有奇数长度和偶数长度两种，因此中心可能是一个点也可能是两个点。

11. 贪心算法。贪心每一步选一个最优解，局部最优构成全局最优。每一步的选择不会更改，这与回溯不同。

- H45：跳跃游戏II。贪心策略是，每一步选择当前可选择的范围内，下一步可达最远的那个位置。

## 数据结构

1. 链表

- M61：旋转链表。获取长度，首尾相接，断开n-k。

- M86：分隔链表。创建两个头结点分别保存较大、较小的链表，最后把较大链表接到较小链表之后。

2. 栈

- M151：翻转字符串里的单词。双指针获取单词，用栈反向输出到列表，使用String.join()。

- M445：两数相加。用两个栈把链表的数输出。从栈弹出数字相加，注意可以通过把分支合并减少代码量。

3. 哈希表

- M846：一手顺子。TreeMap保存每张牌的个数，并按牌大小排序，看能否构成整数手的顺子。

- E1：两数之和。哈希表存储访问过的元素的位置，判断map中是否有target-nums[i]。
不用担心数字被重复使用的问题，因为第一次访问数字时，map里还没有这个数字。

4. 矩阵

- P0107：旋转矩阵。旋转九十度，先沿左上右下对角线翻转，再沿竖中轴线翻转。

- M54：螺旋矩阵。模拟顺时针打印过程。定义左上、右下两个顶点作为边界，定义当前位置坐标，一次循环触碰到边界则转向。
一次循环结束，边界收缩。循环结束后，继续打印剩余的一行或一列元素。

5. 前缀树Trie

- M820：单词的压缩编码。单词按长度从大到小排序，逐个插入Trie。如果插入过程没有新建结点，则不需计算单词长度。

6. BST树

- M98：验证BST树。中序遍历，判断遍历结果是否单调递增。注意结点值为整数最大复数、只有一个结点等边界情况。

7. 树

- M102：二叉树的层序遍历。使用队列存储待访问的结点，每访问一个结点把其非空孩子结点加入队列。每一次访问的节点数，是访问开始前队列的长度。

8. 数据结构设计

- M146：LRU缓存。使用双向链表保存缓存，使用HashMap保存指向链表元素的索引。存取时更新队列和map。

- Q59：队列的最大值。一个队列，一个双向链表。队列作为正常使用，双向链表保存当前最大值。
新元素比链表尾部的大，则链表尾部弹出，然后插入新元素；小于等于链表尾部则插入尾部。

## 数学

1. 表达式求值：逆波兰式求解

2. 排列组合

- M60：第k个排列。以任意字母开头的排列数为(n-1)!，计算k对应第几个数开头，并用余数继续计算剩余的开头字母。

3. 数学问题模拟

- M43：字符串相乘。开辟定长数组，数字倒序打印，注意乘数为0。

- M8：atoi。从高位到低位累加，ans = ans*10 + digit。ans > (Integer.MAX_VALUE - digit)/10，则数字超过整数范围。

- M36：有效的数独。维护三个Map数组，存储行、列、格里出现过的数字。对位置(i,j)来说，其对应的格为(i/3)*3+(j/3)。

4. 数学公式计算

- M55：跳跃游戏。计算出当前位置的最远可达位置，不断维护最远可达位置。

- E191：位1的个数。数字n和n-1进行与运算，会把最后一个1反转。

- M338：比特位计数。利用数字之间1的位数的关系求解。奇数比之前的偶数多1，偶数与除以2得到的数字一样。

## sql

- M177：第N高的薪水。set N = N - 1; select salary from employee limit 1 offset N;

- M180：连续出现的数字。把一张表定义三次，三张表的id连续递增，num相等。以此条件筛选出num并去重。

- M178：分数排名。父查询按照分数递减排序，子查询count比父查询大的Score个数作为排名。

## 其他

1. 多线程

