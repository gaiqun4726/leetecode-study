## 第一季

### MQ
5. 消息队列如何选型？

消息队列的三个优点：解耦、异步、消峰填谷。消息队列的缺点：系统复杂度增高，可用性降低。

activemq：社区不活跃，基本不用。

rabbitmq：吞吐量每秒上万消息级别。erlang开发，处理速度快。社区活跃，阅读源码困难。适合中小公司。

rocketmq：吞吐量十万级别。java开发，易于自研。阿里背书，需要团队自研。适合大公司。

kafka：大数据领域实际标准。

6. 消息队列如何保证高可用？
rabbitmq：不是分布式系统，HA通过使用镜像集群模式完成。集群里每个结点存放的消息完全一样。

kafka：kafka从0.8版本以后开始支持HA，每个topic分为多个partition，每个partition有多个replica。
replica分为leader和follower，分布在不同的broker上。

7. 如何保证消息不重复？消息幂等消费
如果消费端消费了消息，但还未提交时，消费者挂了，那么mq会以为消息没有被消费，因此会重发一遍。
消息不重复是不可能的，只能保证幂等消费。
由消费者保证幂等消费，可以保存消费过的消息列表，或者利用数据库的唯一键避免重复消费。

8. 如何保证消息不丢失？
rabbitmq：发送端channel设置为confirm模式（非阻塞异步），回调生产者接口重试；mq队列设置为持久化、消息设置为持久化；消费端关闭auto ack，手动ack。
rabbitmq发送端支持事务吗？一般不使用事务模式（同步阻塞）。

kafka：发送端设置为ack=all，retries=较大次数；topic设置replication.factor>1, min.insync.replicas>1；消费端关闭自动提交offset，手动提交。

9. 如何保证消息的顺序性？


## 第三季

26. spring IOC机制
干了什么：管理Bean的创建，管理依赖的注入
底层技术：反射技术，通过反射创建类的实例，通过反射找到注解对应的依赖
有什么用：代码解耦，面向接口编程

65. cpu 100%如何排查问题？
top -c 查看线程cpu使用情况，P按照cpu使用率排序，得到占用率最高的进程ID；
top -Hp 进程ID，输入P排序，查看cpu使用率最高的线程ID；
printf "%x\n" 线程ID，把线程ID转换为16进制；
jstack 进程ID | grep 16进制线程ID -C5 --color 打压虚拟机栈信息；
虚拟机栈会打印当前正在执行的代码。
我们项目中可能出现问题的地方：kafka的消费者，反序列化如果抛出异常，就不会ack，会导致重复消费反序列化失败的消息，进入死循环。

66. kill杀不死进程怎么办？磁盘空间快满了怎么处理
